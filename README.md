# SE_LAB 2
Version Control System - Software Engineering Lab

# Group
Yasaman Sheikhan - 97101915\
Amirhossein Alimohammadi  - 97110166

# Report

در ابتدا بر روی برنچ main فایل main.py را با استفاده از دستور touch می سازیم و کامیت می کنیم و سپس بر روی گیت هاب قرار می دهیم.
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic1.png" height="600">
</p>

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic2.png" height="600">
</p>

سپس فایل مربوط به merge_sort را ایجاد می کنیم و آن را پوش می کنیم. سپس نوبت به این می رسد که یک برنچ جدید به اسم dev بسازیم و حال در
این برنچ تغییراتی بر روی merge_sort می دهیم تا با برنچ main امان کانفلیکت داشته باشد. 

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic4.png" height="600">
</p>

حال وقتی روی برنچ dev هستیم یک pul request به برنچ main می زنیم و به دلیل وجود conflict پروسه ی pull ما fail می شود. حال از دستور $git mergetool$ استفاده می کنیم.
پس از وارد کردن دستور با صفحه زیر مواجه می شویم که هر دو کد را پشت سر هم آورده است.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic5.png" height="600">
</p>

بخش هایی از دو کد که می خواهیم در ورژن نهایی باشد را انتخاب می کنیم و سپس دکمه Esc را فشار می دهیم و :wq را وارد می کنیم تا تغییرات ذخیره شود.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic6.png" height="600">
</p>

و سپس می توان دید که pull با موفقیت انجام شد.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic7.png" height="600">
</p>

کد ها را تکمیل تر می کنیم که پروسه ی تکمیل شدنشان در کامیت ها موجود است. سپس یک باگ در کد اصلی بر روی برنچ اصلی را در برنچ hotfix حل می کنیم و مشابه روند بالا 
مشکل کانفلیکت را با mergetool بر طرف می کنیم.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic8.png" height="600">
</p>

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic9.png" height="600">
</p>




# Questions
## 1.

این پوشه شامل تمام اطلاعات مورد نیاز برای ثبت تاریخچه کامیت‌ها، اطلاعات ریپازیتوری، کنترل نسخه‌های مختلف مخزن، آدرس‌ها و غیره میباشد و پس از اجرای  دستور گیت اینیت این پوشه ساخته می‌شود. در حالت عادی این پوشه پنهان است تا کسی به‌صورت تصادفی آن را پاک نکند و یا تغییری ندهد. اطلاعات و محتوای آن در پوشه‌های مختلفی ذخیره می شوند که معانی متفاوتی داشته و همچنین شامل یک گزارش یا لاگی است که تاریخچه کامیت‌ها را ذخیره می کند و میتواند به ما در بازگشتن به نسخه موردنظر کد کمک کند
## 2.
منظور از اتمیک بودن این است که سیسستم همواره در یک حالت پایدار قرار داشته باشد و امکان انجام همزمان دو یا تعداد بیشتری عملیات کامیت وجود نداشته باشد. درواقع کامیت یا پول ریکویست یا به طول کامل و با حالت موفقیت انجام می‌شود و یا کلا انجام نمی‌شوند و حالت شکست را دارند. بنابراین اگر درهنگام انجام این دو عملیات مشکلی ایجاد شود، تمامی تغییراتی که تا آن لحظه اعمال شده بودند، حذف شده و پروژه به حالت قبلی خود برمی‌گردد یا اگر مشکلی ایجاد نشود، تمامی تغییرات با موفقیت روی پروژه اعمال می‌شوند. هر پول ریکویست میتواند شامل یک یا تعداد بیشتری کامیت باشد
## 3.
به طور کلی دو نوع شاخه در گیت وجود دارد:
شاخه محلی که روی سیستم شما به صورت لوکال ذخیره میشود و شاخه ریموت که روی یک سیستم دیگری وجود دارد و برای استفاده از آن به یک کپی به صورت شاخه محلی نیاز دارید. وقتی برنچ ریموت تغییر میکند این تغییرات مستقیم بر روی برنچ لوکال اعمال نمیشود و گیت از تغییراتی که روی ریموت اعمال شده بی خبر است.
 git fetch:
این دستور اطلاعات جدید را از مخزن ریموت دریافت میکند ولی هیچ تغییری روی شاخه های محلی اعمال نمیکند
 و پس از اجرا کردن این دستور، گیت متوجه میشود که مخزن محلی چه تفاوت هایی نسبت به مخزن ریموت دارد.
 git merge:
اگر این دستوراز روی یک شاخه بر روی شاخه دیگری اجرا شود، به این معناست که تغییرات برنچ دوم را روی برنچ اول اعمال کن
مثال:

              F---E local branch B
             /
    A---B---C---D   local branch A
اگر روی برنچ اول باشید ومرج با برنچ دوم را اجرا کنید آنگاه تغییرات برنچ دوم روی اولی اعمال شده و یک کامیت جدید ساخته میشود


              F---E     local branch B
             /     \
    A---B---C---D---G   local branch A

 git pull:
این دستور از روی یک شاخه محلی بر روی یک شاخه از راه دور اعمال شده و باعث میشود ابتدا با استفاده از گیت فچ اطلاعات جدید از مخزن ریموت دریافت شده و سپس با استفاده از گیت مرج تغییرات دریافت شده نیز اعمال شود
به طور مثال اگر دستور پول را روی برنچ  دوم اجرا کنید تغییرات جدید برنچ دوم بر روی برنچ محلی اول اعمال میشود. یعنی ابتدا فچ و سپس مرج میشود
