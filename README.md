<div dir=”rtl”>
 
 # آزمایش دوم آزمایشگاه مهندسی نرم‌افزار
عنوان آزمایش: مدیریت نسخ پروژه و یکپارچه‌سازی مستمر
 
 ## اعضای گروه
 یاسمن شیخان - 97101915 و امیرحسین علی‌محمدی - 97110166
 
 
## گزارش

در ابتدا بر روی برنچ main فایل main.py را با استفاده از دستور touch می سازیم و کامیت می کنیم و سپس بر روی گیت هاب قرار می دهیم.
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic1.png" height="600">
</p>

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic2.png" height="600">
</p>

سپس فایل مربوط به merge_sort را ایجاد می کنیم و آن را پوش می کنیم. سپس نوبت به این می رسد که یک برنچ جدید به اسم dev بسازیم و حال در
این برنچ تغییراتی بر روی merge_sort می دهیم تا با برنچ main امان کانفلیکت داشته باشد. 

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic4.png" height="600">
</p>

حال وقتی روی برنچ dev هستیم یک pul request به برنچ main می زنیم و به دلیل وجود conflict پروسه ی pull ما fail می شود. حال از دستور $git mergetool$ استفاده می کنیم.
پس از وارد کردن دستور با صفحه زیر مواجه می شویم که هر دو کد را پشت سر هم آورده است.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic5.png" height="600">
</p>

بخش هایی از دو کد که می خواهیم در ورژن نهایی باشد را انتخاب می کنیم و سپس دکمه Esc را فشار می دهیم و :wq را وارد می کنیم تا تغییرات ذخیره شود.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic6.png" height="600">
</p>

و سپس می توان دید که pull با موفقیت انجام شد.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic7.png" height="600">
</p>

کد ها را تکمیل تر می کنیم که پروسه ی تکمیل شدنشان در کامیت ها موجود است. سپس یک باگ در کد اصلی بر روی برنچ اصلی را در برنچ hotfix حل می کنیم و مشابه روند بالا 
مشکل کانفلیکت را با mergetool بر طرف می کنیم.

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic8.png" height="600">
</p>

<p align="center">
<img src="https://github.com/yasmansh/SE_LAB2/blob/main/gozaresh/pic9.png" height="600">
</p>


 
 ## پرسش‌ها
 ### 1. پوشه‌ی . git چیست؟ چه اطلاعاتی در آن ذخیره میشود؟
 
این پوشه شامل تمامی اطلاعات مورد نیاز برای ثبت تاریخچه کامیت‌ها، اطلاعات مخزن از راه دور(remote repository)، کنترل نسخه‌های مختلف مخزن و آدرس آن‌ها و غیره میباشد و پس از اجرای  دستور git init این پوشه ساخته می‌شود. در حالت عادی پوشه .git پنهان است تا کسی به‌صورت تصادفی آن را پاک نکند و یا تغییری در آن ایجاد نکند. اطلاعات و محتوای این پوشه در پوشه‌های مختلفی ذخیره می شوند که معانی متفاوتی دارد. به طور مثال پوشه refs حاوی اطلاعات مربوط به تگ‌ها و شاخه‌ها می‌باشد. همچنین پوشه .git شامل یک گزارش(log) است که تاریخچه کامیت‌ها را ذخیره کرده و میتواند به ما در بازگشتن به نسخه موردنظر مخزن کمک کند. اندزه پوشه .git ممکن است زیاد باشد زیرا تمامی اطلاعات لازم برای بازیابی فایل‌ها و تاریخچه کامیت‌ها را نگهداری میکند.
 
 ### 2. منظور از atomic بودن کامیت و pull request چیست؟
 
منظور از atomic بودن این است که سیسستم همواره در یک حالت پایدار قرار داشته باشد و امکان انجام دو یا تعداد بیشتری عملیات(commit یا pull request) به طور همزمان وجود نداشته باشد. فرآیند atomic یا به طور کامل اجرا می شود یا اصلاً اجرا نمی شود . این بدان معناست که عملیات در طول اجرای آن قابل مشاهده نیست، بلکه فقط قبل و بعد از آن قابل مشاهده است. درواقع commit یا pull request یا به طول کامل انجام میشود که حالت succeed را دارد و یا کلا انجام نمی‌شوند و حالت fail را دارد. بنابراین اگر درهنگام انجام این دو عملیات مشکلی ایجاد شود، تمامی تغییراتی که تا آن لحظه اعمال شده بودند، حذف شده و پروژه به حالت قبلی خود برمی‌گردد یا اگر مشکلی ایجاد نشود، تمامی تغییرات با موفقیت روی پروژه اعمال می‌شوند. هر  pull request میتواند شامل یک یا تعداد بیشتری کامیت اتمیک باشد.
 
 ### 3. تفاوت دستورهای fetch و pull و merge را بیان کنید. مثال بزنید.
 
 به طور کلی دو نوع شاخه(branch) در گیت وجود دارد:

شاخه محلی (local branch): این شاخه روی سیستم ما به صورت لوکال ذخیره میشود.<br>
شاخه از راه دور(remote branch): این شاخه بر روی یک سیستم دیگه وجود دارد و برای استفاده از آن نیاز دارید یک کپی به صورت local branch داشته باشید.<br>
در واقع هرکس یک کپی از remote branch روی repository خود دارد و وقتی شاخه ریموت تغییر میکند، این تغییرات مستقیم بر روی شاخه محلی اعمال نمیشود. و گیت از تغییراتی که روی شاخه ریموت اعمال شده است بی‌خبر میباشد. <br>
به طور مثال تصویر زیر یک repository بر روی شاخه محلی و از راه دور را نشان میدهد. همانطور که مشخص است شاخه ریموت B جلوتر از شاخه لوکال B میباشد. (تغییرات توسط یکی دیگر از اعضای تیم انجام شده و روی شاخه ریموت push شده است)<br>

              F---E--G--H remote branch B
             /
    A---B---C---D         remote branch A
---------------------------------------------------------------
              F---E local branch B
             /
    A---B---C---D   local branch A

 دستور git fetch: این دستور اطلاعات جدید را از repository ریموت دریافت میکند ولی هیچ تغییری روی برنچ های local‌ اعمال نمیکند. در مثال بالا پس از اجرا کردن دستور git fetch، گیت متوجه میشود که repository محلی شما چه تفاوت هایی نسبت به مخزن ریموت دارد. و این اطلاعات را روی شاخه‌ای با نام remote-name/branch-name ذخیره میکند.
 <br>
 
 دستور git merge: اگر دستور git merge از روی یک شاخه بر روی شاخه دومی اجرا شود به این معنا است که تغییرات شاخه دوم را روی شاخه اول اعمال کن. مثال:
 
              F---E local branch B
             /
    A---B---C---D   local branch A
اگر روی شاخه A باشید و git merge B‍ را اجرا کنید، تغییرات شاخه B روی شاخه A اعمال شده و یک commit جدید ساخته میشود(تصویر زیر).

              F---E     local branch B
             /     \
    A---B---C---D---G   local branch A

 دستور git pull: این دستور از روی یک شاخه محلی برروی یک شاخه از راه دور اعمال میشود و باعث میشود ابتدا با استفاده از git fetch اطلاعات جدید از شاخه ریموت دریافت شده و سپس با استفاده از git merge تغییرات دریافت شده روی شاخه محلی اعمال شود. تصویر زیر را درنظر بگیرید. <br>
 
              F---E--G--H remote branch B  
             /  
    A---B---C---D         remote branch A  
---------------------------------------------------------------  
              F---E local branch B  
             /  
    A---B---C---D   local branch A  
 
 اگر روی شاخه B باشید و دستور git pull remote-name B را اجرا کنید تغییرات جدید شاخه remote B بر روی شاخه local A اعمال میشود. ابتدا اطلاعات fetch و سپس بر روی برنچ B مرج میشود. <br> 

              F---E--G--H remote branch B
             /
    A---B---C---D         remote branch A
---------------------------------------------------------------
              F---E--G--H local branch B
             /
    A---B---C---D   local branch A
 
 ### 4. تفاوت دستورهای rebase و clone را بیان کنید و مثال بزنید.
 
 دستور git rebase: این دستور  شبیه دستور git merge است با این تفاوت که دو شاخه را با یک استثنا در یک شاخه واحد ادغام می کند. یک دستور git rebase تاریخچه کامیت را بازنویسی می کند. و اگر چند شاخه خصوصی دارید باید از دستور git rebase برای ادغام در یک شاخه استفاده کنید. این باعث می شود که یک تاریخچه کامیت خطی بسازید. همچنین دستور git rebase اجازه می دهد تغییرات را از یک شاخه با یک شاخه دیگر ادغام کنند. <br>

$ git rebase <base>
 
 مثال: <br>
 
 before rebase: <br>

A <- B <- C <br>
^         ^ <br>
 \         \ <br>
  D <- E <- F <br>

after git rebase master:<br>

A <- B <- C <- D' <- E'<br>

 دستور git clone: از دستور git clone برای کپی یک نسخه موجود از مخزن استفاده می شود. دستور git clone ابتدا از دستور git init استفاده می کند سپس تمام محتوای آن را بررسی خواهد کرد. <br>
 
 برای مثال اگر می‌خواهید جهت توسعه یک کپی کامل از یک مخزن موجود را داشته باشید، دستوری که به آن احتیاج دارید git clone است. به صورت پیش‌فرض با اجرای دستور git clone هر نسخه‌ای از هر فایلی که در تاریخچهٔ پروژه است توسط گیت آورده می‌شود. در حقیقت اگر احیاناً دیسک سرور شما دچار مشکل گردد و اطلاعات از دست روند غالباً می‌توانید به طور مستقیم از هر کلون دیگری روی هر کلاینت دیگری استفاده کنید تا اطلاعات سرور را به همان حالتی که به هنگام کلون کردن بود بازگردانید. <br>
 
 $ git clone https://github.com/libgit2/libgit2
 
با اجرای خط بالا در مرحلهٔ اول یک پوشه به نام libgit2 ساخته می‌شود، در پوشه libgit2 یک پوشه جدید به نام .git ساخته شده و مخزن گیت راه‌اندازی ‌می‌شود، تمام اطلاعات از مخزن اصلی دریافت می‌شوند و ما را به اخرین نسخه از پروژه چک‌اوت می‌کند. اگر وارد پوشه جدید libgit2 شوید، ‌خواهید دید که فایل‌های پروژه حاضر و آماده استفاده هستند.<br>

### 5. تفاوت دستورهای reset و revert را بیان کنید. مثال بزنید.
 
 دستور revert: یک commit جدید ایجاد خواهد کرد که ما را به commit قبلی برمیگرداند و نکته اینجاست که به تاریخچه موجود ما تغییری اعمال نمی شود. در هنگام استفاده از git revert باید کامیتی را وارد کنید که می‌خواهید undo شود نه کامیتی که می‌خواهید به آن برگردید. به طور مثال با دستور git revert HEAD آخرین کامیت آندو شده و به کامیت قبلی برمیگردیم. <br>

دستور reset: این دستور برای این است که به یک نقطه خاص از تاریخچه ای که داریم بازگردیم. دستور git reset فقط روی working directory و ناحیه staging کار می‌کند. بنابراین کامیت‌های ما در امان هستند و تغییری در تاریخچه(git log) به وجود نمی‌آید. به طور مثال با اجرای git checkout A reset HEAD~2 میتوان شاخه A را به دو کامیت قبل آن برگرداند. 
 
 ### 6. منظور از stage و snapshot چیست؟
 
 گیت دارای سه حالت اصلی است که فایل‌های شما می‌توانند در آن‌ها قرار گیرند:modified, staged و committed.

حالت Modified به این معنی است که شما فایل را تغییر داده‌اید اما هنوز آن را کامیت نکرده‌اید. staged به این معنی است که شما یک فایل Modified  را در نسخه فعلی آن علامت گذاری کرده اید تا به commit snapshot بعدی بروید. حالت stage یک مرحله قبل از commit است. یعنی تا زمانی که تغییرات در حالت stage باشند تا قبل از کامیت کردن می‌توان تغییرات را اعمال کرد.  از طرفی در گیت با هر کامیت، یک snapshot از تمام فایل‌های فعلی repository ساخته می‌شود که حالت فعلی تمامی فایل‌ها را در تا آن زمان نگهداری می‌کند. درواقع با استفاده از snapshot می‌توانیم به کامیت‌های گذشته برگردیم.  در حقیقت هربار که یک تغییر در فایل‌ها ایجاد شده و کامیت شود، ابتدا گیت تغییرات را چک می‌کند و اگر چیزی تغییر کرده باشد، آن را فشرده کرده و در داخل دایرکتوری objects ذخیره میکند و هش آن را به snapshot اضافه میکند و نهایتاً خود این اسنپ‌شات هم فشرده سازی شده و یک هش برای ارجاع دادن اختصاص داده میشود. اگر هم فایلی تغییر نکرده باشد، گیت هش قبلی فایل را در اسنپ شات فعلی ذخیره می‌کند تا نیازی به ذخیره مجدد آن نباشد.
 
</div>
